// Copyright: 2016-2018 Twinleaf LLC
// Author: gilberto@tersatech.com
// License: Proprietary

// API providing send/recv interface to communicate with sensors seamlessly
// over all the supported protocols.
// In general, if errors occur that are not related to non-blocking I/O the
// mode of recovery is to close the descriptor and open a new one.
// NOTE: this API is non-reentrant and must be explicitly serialized if there
// will be concurrent calls. Never call from a signal handler.

#ifndef TL_SENSOR_IO_H
#define TL_SENSOR_IO_H

#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

// Function signature used for logging (optional). When opening a descriptor,
// a logger can be associated with it, and it will be called with detailed
// error strings. Note: if an error occurs before obtaining a descriptor,
// fd will be -1.
typedef void tlio_logger(int fd, const char *message);

// Open a descriptor to communicate with a sensor. Flags are restricted to
// O_NONBLOCK and O_CLOEXEC, and sensors are always opened for read/write.
// logger can be NULL to suppress error messages.
// Returns a valid descriptor (>=0) on success, otherwise -1 and errno is set.
// The descriptor returned is a valid system descriptor, and can be used for
// polling and other reasons (e.g. setting/clearing nonblocking I/O flag).
// However, reading and writing to the descriptor should be done via tlrecv
// and tlsend, since reading or writing arbitrary data can put the system
// in a bad state.
// The URL format is 'protocol://location/routing/routing/...', where location
// depends on the protocol and routing allows to connect to a sensor deep in
// the sensor tree as if it was the root (ignoring any input from outside that
// subtree, and implicitly prepending that routing data on every output packet).
//
// The 'serial' protocol communicates to a sensor connected via the serial
// port, and its location is 'port_name:bitrate', for example
//    serial://ttyUSB0:115200/1/
// Bitrate is optional, and if omitted will default to
#define TL_SERIAL_DEFAULT_BITRATE 115200
// NOTE: to simplify tab completion and commands, since there is no ambiguity
// the serial protocol also accepts direct device paths, optionally followed
// by bitrate and subpath, e.g. /dev/ttyUSB0:115200/1/
//
// The 'tcp' protocol communicates via TCP/IP and location is an address:port,
//    tcp://host.twinleaf.com:12345/
// Port is optional, and if omitted will default to
#define TL_TCP_DEFAULT_PORT 7855
//
// Similarly, UDP can be used with an URL like this
//    udp://host.twinleaf.com:12345/
// where port is optional and will default to
#define TL_UDP_DEFAULT_PORT 7855
//
int tlopen(const char *url, int flags, tlio_logger *logger);

// Use a descriptor already opened for I/O with a twinleaf sensor. Note that
// you still need to specify a valid protocol as in tlopen(). Returns fd, or -1
// in case of error.
int tlfdopen(int fd, const char *protocol, const char *routing,
             tlio_logger *logger);

// Close a descriptor opened with tlopen/tlfdopen. Calls close() after
// libtio specific cleanup. Returns 0 on success, -1 on failure
// (in which case fd was not closed).
int tlclose(int fd);

// Receive a packet. Returns 0 if successful, -1 in case of error.
int tlrecv(int fd, void *packet_buffer, size_t bufsize);

// Send a packet. Returns 0 if successful, -1 on error.
// When using nonblocking I/O, you must carefull check errno for the
// following conditions:
// EAGAIN/EWOULDBLOCK: the packet was not sent because the operation would
//                     block
// EOVERFLOW: the packet was partially sent, but it overflowed the output
//            buffers, and the remaining part was buffered internally,
//            to be sent out on the next call to tlsend()
// ENOTEMPTY: the packet was not sent because there was another part of the
//            previous packet left to send in the buffer, and could not be
//            fully sent before processing the current packet.
//
// In the latter two cases, part of the packet will not be sent out until
// tlsend() is called again. It can be called with packet == NULL to flush
// out the internal buffer, in which case it will return -1/EOVERFLOW until
// the full packet could be written out, returning 0. (Other errors unrelated
// to the buffering behavior will have their own ERRNO values still).
//
// The errno values are usually used for errors unrelated to I/O, so that
// they should not overlap with errors generated by I/O functions in the
// particular send implementation.
//
// Unfortunately this complication arises from the fact that there is no good
// portable way to write packets atomically to byte streams, and in some
// cases a partial write would mean having to close the stream and open
// a new connection to the sensor.
//
// Luckily, for most application it's possible to just use blocking I/O, or
// simply throw the towel on any failure in nonblocking mode (since the
// OS buffers should be big enough to make it very unlikely to ever block).
int tlsend(int fd, const void *packet);

#ifdef __cplusplus
}
#endif

#endif // TL_SENSOR_IO_H
